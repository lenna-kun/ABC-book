# プライオリティキュー
次の2つの操作が行えるデータ構造を，プライオリティキューといいます．

- 値の追加
- 最小の値の取り出し

プライオリティキューは，ヒープ(木)と呼ばれるデータ構造を用いて実装されます．ヒープは，親の数字よりも子の数字が大きくなっている2分木です．2つの操作の計算量は，どちらも\\(O(\log n)\\)です．

ある値の集合から，最小値(最大値)を何度も取り出す状況を考えてみてください．集合に対して，途中で値の追加がなければ，最初にソートし，そこから1番後ろの値を順番に取り出すことで実現できます．しかし，この方法の場合，取り出しにかかるコストは\\(O(1)\\)ですが，途中で値が追加される場合は，ソートを崩さないように値を挿入する必要があり，挿入する場所を求めるのに2分探索を使って\\(O(\log n)\\)，挿入に\\(O(n)\\)かかってしまいます．

そこで，プライオリティキューを使うことで，最小値(最大値)の取り出し，値の追加をともに\\(O(\log n)\\)と高速に行うことができます．

Pythonでは，[heapq](https://docs.python.org/3/library/heapq.html)
というライブラリを使ってListをプライオリティキュー化することが可能です．最小値の取り出しや値の追加を行う関数も用意されています．

```py
# L : List(Lはリスト)
# Convert L from List to Priority Queue(Lをプライオリティキューに変更)
import heapq # Use heapq library(heapqライブラリを使用)
L = [1, 2, 3, 4, 5]
heapq.heapify(L)

# heappop: pop out the minimum number and return it 
# 最小値を見つけてそれをプライオリティキューから取り出し，その値を返す
print(heapq.heappop(L)) # 1
print(L) # [2, 4, 3, 5]

# 注意: ヒープをListを使って表現しているだけなので，Listの中身はソートされているわけではない

# heappush: add item (新たに値を加える．ここでは100を加えている) 
heapq.heappush(L, 100)
```