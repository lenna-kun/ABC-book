# 調和級数(Harmonic Series) ABC134-D Preparing Boxes
[https://atcoder.jp/contests/abc134/tasks/abc134_d](https://atcoder.jp/contests/abc134/tasks/abc134_d)

実行時間制限: 2 sec / メモリ制限: 1024 MB

## 問題
\\(N\\)個の空の箱が横一列に並んでいます。 左から \\(i(1≤i≤N)\\)番目の箱には整数\\(i\\)が書かれています。<br>
すぬけさんは、それぞれの箱に対してボールを\\(1\\)個入れるか何も入れないかを選ぶことができます。<br>
ここで、以下の条件を満たすようなボールの入れ方を、いいボールの入れ方と定めます。
 - \\(1\\)以上\\(N\\)以下の任意の整数\\(i\\)について、\\(i\\)の倍数が書かれた箱に入っているボールの個数の和を\\(2\\)で割った余りが\\(a_i\\)
である。

いいボールの入れ方は存在するでしょうか。存在するならば \\(1\\)つ求めてください。

## 制約
 - 入力は全て整数である
 - \\(1\leq N \leq 2 \times 10 ^ 5 \\)
 - a_iは\\(0\\)または\\(1\\)である。

## 解法
以下、\\(k\\)番目の箱にボールが入っているか否かを\\(b_k\\)で示す。（\\(b_k = 1\\)の時はボールが入っており、\\(b_k=0\\)の時は入っていない。）
<br>
普通に\\(a_1\\)から順に考えていくとどうなるか。例えば\\(a_1\\)が\\(0\\)だった時は
 - 全ての箱にボールなし
 - 1番目の箱と2番目の箱にボールがあってあとは全部ボールなし
 - .....

ここで、二つ目のようにボールが2個入っている場合、何番目を選ぶかで\\( {}_N {C}_2 \\) 通りあることに気づく。さらに次の\\(a_2\\)と辻褄合わせなければならない。それだけではない、\\(a_3、a_4\\)。。。とも辻褄合わせをする必要があり、キリがないことに気が付く。この方法は<font color="Red">非現実的</font>である。

そこで、 \\(N\\) 番目から注目していく。\\(a_N = 1\\)だった時は次のケースが考えられる。
 - \\(N\\)番目の箱にボールが入っている　(すなわち\\(b_N=1\\))

\\(N-1\\)番目以下は絶対に\\(N\\)の倍数ではないため、\\(N-1\\)番以下の箱のことは考えなくて良い。
このように大きな数から計算していくと良さそうである。これで例えば\\(k:1\leq k \leq N \\)の時の\\(b_k\\)を決めるには

 - \\(k\\)以上\\(N\\)以下の\\(k\\)の倍数の\\(b\\)を加える
 - 上記の総和の\\(2\\)の倍数が\\(a_k\\)と一致していたら\\(b_k=0\\)、そうでなければ\\(b_k=1\\)(辻褄あわせ)

このkのパターンを1まで考えていけばよい。
この問題は、計算量の見積もりがやや難しい。

先程の\\(k\\)の時の\\(b_k\\)を決める手順で倍数を加える回数は<font color="Red">\\(k\\)以上\\(N\\)以下の\\(k\\)の倍数</font>回であり、これは高々\\(\frac{N}{k}\\)回である。\\(k\\)は\\(1\leq k \leq N \\)であったので、このやり方での計算量は
\\[
    \frac{N}{1} + \frac{N}{2} + ... + \frac{N}{N} = N (\frac{1}{1} + \frac{1}{2} + ... + \frac{1}{N})
\\]
であり、実は右辺の分数部分は高々\\(\log N\\)である。（高校の数学で\\( \int \frac{1}{x}dx = \log x + C\\)であったのを思い出すと、上の式は似ている。）
よって、計算量は\\(N \log N\\)となり間に合う。
この分数部分の計算は<b>[調和数](https://ja.wikipedia.org/wiki/%E8%AA%BF%E5%92%8C%E6%95%B0_(%E7%99%BA%E6%95%A3%E5%88%97))</b>と呼ばれている。

## 実装

```py
n = int(input())
a = [*map(int, input().split())]
ans = [0]*n
b = []

for i in range(n, 0, -1): # O(N log N)
  ans[i-1] = 1^(sum(ans[i-1:n:i])%2 == a[i-1])
  if ans[i-1]:
    b.append(i)
print(len(b))
print(*b)
```