# 調和級数(Harmonic Series) ABC134-D Preparing Boxes
[https://atcoder.jp/contests/abc134/tasks/abc134_d](https://atcoder.jp/contests/abc134/tasks/abc134_d)

実行時間制限: 2 sec / メモリ制限: 1024 MB

## 問題
\\(N\\)個の空の箱が横一列に並んでいます。 左から \\(i(1≤i≤N)\\)番目の箱には整数\\(i\\)が書かれています。<br>
すぬけさんは、それぞれの箱に対してボールを\\(1\\)個入れるか何も入れないかを選ぶことができます。<br>
ここで、以下の条件を満たすようなボールの入れ方を、いいボールの入れ方と定めます。
 - \\(1\\)以上\\(N\\)以下の任意の整数\\(i\\)について、\\(i\\)の倍数が書かれた箱に入っているボールの個数の和を\\(2\\)で割った余りが\\(a_i\\)
である。

いいボールの入れ方は存在するでしょうか。存在するならば \\(1\\)つ求めてください。

## 制約
 - 入力は全て整数である
 - \\(1\leq N \leq 2 \times 10 ^ 5 \\)
 - a_iは\\(0\\)または\\(1\\)である。

## 解法
以下、\\(k\\)番目の箱にボールが入っているか否かを\\(b_k\\)で示す。（\\(b_k = 1\\)の時はボールが入っており、\\(b_k=0\\)の時は入っていない。）
<br>
普通に\\(a_1\\)から順に考えていくとどうなるか。例えば\\(a_1\\)が\\(0\\)だった時は
 - 全ての箱にボールなし
 - 1番目の箱と2番目の箱にボールがあってあとは全部ボールなし
 - .....

ここで、二つ目のようにボールが2個入っている場合、何番目を選ぶかで\\( {}_N {C}_2 \\) 通りあることに気づく。さらに次の\\(a_2\\)と辻褄合わせなければならない。それだけではない、\\(a_3、a_4\\)。。。とも辻褄合わせをする必要があり、キリがないことに気が付く。この方法は<font color="Red">非現実的</font>である。

他の方法を考えてみる。逆に \\(N\\) 番目から注目していく。\\(a_N = 1\\)だった時は次のケースが考えられる。
 - \\(N\\)番目の箱にボールが入っている　(すなわち\\(b_N=1\\))

実はこれだけである。\\(N-1\\)番以下の箱のことは考えなくて良い。なぜならば\\(N-1\\)番目以下は絶対に\\(N\\)の倍数ではないからである。
このように大きな数から計算していくと良さそうである。これで例えば\\(k:1\leq k \leq N \\)の時の\\(b_k\\)を決めるには

 - \\(k\\)以上\\(N\\)以下の\\(k\\)の倍数の\\(b\\)を加える
 - 上記の総和の\\(2\\)の倍数が\\(a_k\\)と一致していたら\\(b_k=0\\)、そうでなければ\\(b_k=1\\)(辻褄あわせ)

やはりこれだけである。\\(k-1\\)以下の数については一切考慮しなくてよい。
このkのパターンを1まで考えていけばよい。
ところでこれは２重ループになりそうである。普通２重ループは計算量が\\(O(n^2)\\)であり、<b>制約</b>が \\(1\leq N \leq 2 \times 10 ^ 5 \\)だったので間に合わなさそうであるが、これは実は<font color="Red"><b>計算量が\\(O(n^2)\\)よりも小さく、間に合う</b></font>のである。

どういうことか。
先程の\\(k\\)の時の\\(b_k\\)を決める手順で倍数を加える回数は<font color="Red">\\(k\\)以上\\(N\\)以下の\\(k\\)の倍数</font>回であり、これは高々\\(\frac{N}{k}\\)回である。\\(k\\)は\\(1\leq k \leq N \\)であったので、このやり方での計算量は
\\[
    \frac{N}{1} + \frac{N}{2} + ... + \frac{N}{N} = N (\frac{1}{1} + \frac{1}{2} + ... + \frac{1}{N})
\\]
であり、実は右辺の分数部分は高々\\(logN\\)である。（高校の数学で\\( \int \frac{1}{x}dx = logx + C\\)であったのを思い出すと、上の式は似ている。。）
なので、実は計算量は\\(NlogN\\)となり間に合う。
この分数部分の計算は<b>[調和級数](https://ja.wikipedia.org/wiki/%E8%AA%BF%E5%92%8C%E7%B4%9A%E6%95%B0)</b>と呼ばれている。
## 実装
```py
N = int(input())
B = list(map(int,input().split()))
A = [0]
# 問題文のiとA[i]を合わせるためA[0]を先頭に追加。Bも同様
A.extend(B)
ret = [0] * (N + 1)
for i in range(N,0,-1): #このループが計算量N
    tmp = ret[i]
    j = i
    while j <= N:#この部分の計算量はlogN
        tmp += ret[j]
        j += i
    if tmp % 2 != A[i]:
        ret[i] = 1
count = sum(ret)
if count == 0:
    print(0)
    exit()
ret = ' '.join([str(i) for i in range(len(ret)) if ret[i] == 1])
print(count)
print(ret)
```